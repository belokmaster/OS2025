#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include <string.h>

/*
Данный код реализует взаимодействие между двумя процессами через разделяемую память и семафоры для синхронизации. 
Один процесс записывает данные в разделяемую память, а другой процесс их считывает, при этом используется семафор для управления доступом и 
предотвращения потери данных. Код гарантирует, что данные будут записаны и считаны без потери и гонки за ресурсами.
*/

// Размер разделяемой памяти
#define SHM_SIZE 1024

// Ключи для разделяемой памяти и семафора
#define SHM_KEY 1234    // Ключ для разделяемой памяти
#define SEM_KEY 5678    // Ключ для семафора

// Структура, описывающая данные в разделяемой памяти
struct shared_memory {
    char data[SHM_SIZE];  // Буфер для хранения данных
    int written;          // Флаг, указывающий, что данные записаны
};

// Функция для создания и инициализации семафора
int create_semaphore() {
    // Создание семафора с заданным ключом и правами доступа
    int semid = semget(SEM_KEY, 1, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("Ошибка создания семафора");
        exit(EXIT_FAILURE);
    }

    // Инициализация семафора: значение 1 разрешает доступ для записи
    semctl(semid, 0, SETVAL, 1);
    return semid;
}

// Функция для захвата семафора (блокировка)
void lock_semaphore(int semid) {
    struct sembuf sb = {0, -1, 0};  // Уменьшаем семафор на 1 (блокировка)
    semop(semid, &sb, 1);  // Выполнение операции
}

// Функция для освобождения семафора (разблокировка)
void unlock_semaphore(int semid) {
    struct sembuf sb = {0, 1, 0};  // Увеличиваем семафор на 1 (разблокировка)
    semop(semid, &sb, 1);  // Выполнение операции
}

int main() {
    // Создание разделяемой памяти с заданным ключом
    int shmid = shmget(SHM_KEY, sizeof(struct shared_memory), IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("Ошибка создания разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    // Привязка разделяемой памяти к адресу процесса
    struct shared_memory *shm_ptr = shmat(shmid, NULL, 0);
    if (shm_ptr == (void *)-1) {
        perror("Ошибка привязки разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    // Создание семафора для синхронизации
    int semid = create_semaphore();

    // Создание двух процессов: один для записи, другой для чтения
    pid_t pid = fork();
    if (pid == -1) {
        perror("Ошибка создания процесса");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {  // Дочерний процесс - процесс записи
        for (int i = 0; i < 5; ++i) {
            // Ожидание, если данные уже записаны (блокируем семафор)
            lock_semaphore(semid);

            // Запись данных в разделяемую память
            snprintf(shm_ptr->data, SHM_SIZE, "Данные %d", i);  // Формирование строки
            shm_ptr->written = 1;  // Устанавливаем флаг, что данные записаны

            printf("Записано: %s\n", shm_ptr->data);  // Выводим информацию о записи

            // Освобождение семафора, чтобы процесс чтения мог считать данные
            unlock_semaphore(semid);

            // Задержка для имитации работы
            sleep(1);
        }

        // Открепление разделяемой памяти после завершения работы
        shmdt(shm_ptr);

    } else {  // Родительский процесс - процесс чтения
        for (int i = 0; i < 5; ++i) {
            // Ожидание, пока данные не будут записаны (проверка флага)
            while (shm_ptr->written == 0) {
                // Ждем, пока процесс записи не завершит запись
                sleep(1);
            }

            // Ожидание блокировки семафора, чтобы гарантировать последовательность операций
            lock_semaphore(semid);

            // Чтение данных из разделяемой памяти
            printf("Прочитано: %s\n", shm_ptr->data);

            // Указываем, что данные прочитаны, сбрасываем флаг
            shm_ptr->written = 0;

            // Освобождение семафора, чтобы процесс записи мог продолжить
            unlock_semaphore(semid);

            // Задержка для имитации работы
            sleep(1);
        }

        // Открепление разделяемой памяти после завершения работы
        shmdt(shm_ptr);
    }

    // Удаление разделяемой памяти и семафора после завершения работы процессов
    if (pid != 0) {
        shmctl(shmid, IPC_RMID, NULL);  // Удаляем разделяемую память
        semctl(semid, 0, IPC_RMID);     // Удаляем семафор
    }

    return 0;
}
